# 爆款标题知识库 - 技术实现方案

## 一、技术选型

### 1.1 前端架构（基于现有项目）

```
现有技术栈:
- React 19 + TypeScript
- Vite 7
- Ant Design 5
- React Router
- Axios

标题库新增:
- 无需额外UI库，复用原型的CSS变量
```

### 1.2 后端架构（扩展现有Express服务）

```javascript
// 现有: server/index.cjs (图片上传)
// 新增: server/title-api.cjs (标题库API)

技术栈:
- Express 5 (已有)
- SQLite3 (轻量级关系数据库)
- better-sqlite3 (同步API，性能更好)
```

### 1.3 向量搜索方案

**方案选择: Qdrant (独立向量数据库)**

```yaml
为什么选Qdrant:
  1. 独立部署，不依赖PostgreSQL扩展
  2. 提供Docker镜像，本地开发方便
  3. 有官方Node.js SDK
  4. 支持过滤 + 向量搜索组合
  5. 免费版够用（100万向量）

部署方式:
  开发环境: Docker容器
  生产环境: Docker Compose / Qdrant Cloud
```

### 1.4 AI服务选型

```javascript
支持的AI提供商:
  1. DeepSeek (推荐，性价比高)
     - API: https://api.deepseek.com
     - 模型: deepseek-chat
     - Embedding: 自建或用OpenAI

  2. OpenAI (备选)
     - API: https://api.openai.com
     - 模型: gpt-4o-mini (分析) + text-embedding-3-small (向量)

  3. Claude (备选)
     - API: https://api.anthropic.com
     - 模型: claude-3-haiku (分析)
     - Embedding: 需搭配OpenAI

配置方式:
  - 存储在 SQLite config 表
  - 前端设置页面可切换
  - 支持自定义endpoint（API代理）
```

---

## 二、数据库设计

### 2.1 SQLite Schema

```sql
-- 标题表
CREATE TABLE titles (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  text TEXT NOT NULL,                    -- 标题文本
  source TEXT,                           -- 来源平台
  category TEXT,                         -- 领域分类
  style TEXT,                            -- 风格类型
  status TEXT DEFAULT 'pending',         -- pending | approved | rejected
  psychology TEXT,                       -- JSON数组: 心理分析
  core_pattern TEXT,                     -- 核心套路
  confidence REAL DEFAULT 0,             -- AI分析置信度 0-1
  reference_count INTEGER DEFAULT 0,     -- 引用次数
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 元素表
CREATE TABLE elements (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  text TEXT NOT NULL UNIQUE,             -- 元素文本（如"N个方法"）
  category TEXT NOT NULL,                -- 心理效果分类
  explanation TEXT,                      -- 详细说明
  usage_count INTEGER DEFAULT 0,         -- 使用次数
  effectiveness REAL DEFAULT 50,         -- 有效率 0-100
  tags TEXT,                             -- JSON数组: 标签
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 标题-元素关联表
CREATE TABLE title_elements (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  title_id INTEGER NOT NULL,
  element_id INTEGER NOT NULL,
  mechanisms TEXT,                       -- JSON数组: 作用机制
  FOREIGN KEY (title_id) REFERENCES titles(id) ON DELETE CASCADE,
  FOREIGN KEY (element_id) REFERENCES elements(id) ON DELETE CASCADE,
  UNIQUE(title_id, element_id)
);

-- 元素搭配关系表
CREATE TABLE element_pairs (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  element_id INTEGER NOT NULL,
  pair_element_id INTEGER NOT NULL,
  co_occurrence INTEGER DEFAULT 1,       -- 共现次数
  reason TEXT,                           -- 搭配原因
  FOREIGN KEY (element_id) REFERENCES elements(id) ON DELETE CASCADE,
  FOREIGN KEY (pair_element_id) REFERENCES elements(id) ON DELETE CASCADE,
  UNIQUE(element_id, pair_element_id)
);

-- 元素示例表
CREATE TABLE element_examples (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  element_id INTEGER NOT NULL,
  example_text TEXT NOT NULL,            -- 示例标题
  FOREIGN KEY (element_id) REFERENCES elements(id) ON DELETE CASCADE
);

-- AI配置表
CREATE TABLE ai_config (
  id INTEGER PRIMARY KEY CHECK (id = 1), -- 单例配置
  provider TEXT DEFAULT 'deepseek',      -- deepseek | openai | claude
  api_key TEXT,
  endpoint TEXT,
  model TEXT,
  embedding_provider TEXT DEFAULT 'openai',
  embedding_api_key TEXT,
  embedding_model TEXT DEFAULT 'text-embedding-3-small',
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 创建索引
CREATE INDEX idx_titles_status ON titles(status);
CREATE INDEX idx_titles_category ON titles(category);
CREATE INDEX idx_elements_category ON elements(category);
CREATE INDEX idx_title_elements_title ON title_elements(title_id);
CREATE INDEX idx_title_elements_element ON title_elements(element_id);
```

### 2.2 向量存储（Qdrant Collection）

```javascript
// Qdrant Collection配置
const collectionConfig = {
  name: "title_embeddings",
  vectors: {
    size: 1536,  // OpenAI text-embedding-3-small维度
    distance: "Cosine"
  },
  payload_schema: {
    title_id: "integer",      // 关联SQLite的title.id
    text: "text",             // 标题文本（用于结果展示）
    category: "keyword",      // 领域（用于过滤）
    status: "keyword"         // 状态（用于过滤）
  }
}

// 向量搜索 + 过滤示例
const searchParams = {
  vector: [0.1, 0.2, ...],  // 查询向量
  filter: {
    must: [
      { key: "status", match: { value: "approved" } },
      { key: "category", match: { value: "科技" } }
    ]
  },
  limit: 20,
  with_payload: true
}
```

---

## 三、后端API设计

### 3.1 Express路由结构

```javascript
// server/title-api.cjs
const express = require('express');
const router = express.Router();

// 标题管理
router.post('/titles', addTitle);              // 添加单个标题
router.post('/titles/batch', batchAddTitles);  // 批量导入
router.get('/titles', getTitles);              // 获取标题列表
router.get('/titles/:id', getTitleDetail);     // 获取标题详情
router.put('/titles/:id', updateTitle);        // 更新标题
router.delete('/titles/:id', deleteTitle);     // 删除标题
router.post('/titles/:id/approve', approveTitle); // 审核通过
router.post('/titles/batch-approve', batchApprove); // 批量审核

// 语义搜索
router.post('/titles/search', semanticSearch);  // 向量搜索
router.post('/titles/similar/:id', findSimilar); // 查找相似标题

// 元素管理
router.get('/elements', getElements);           // 获取元素列表
router.post('/elements', createElement);        // 创建元素
router.put('/elements/:id', updateElement);     // 更新元素
router.get('/elements/:id/pairs', getElementPairs); // 获取搭配关系
router.get('/elements/recommend', recommendElements); // 推荐元素

// AI服务
router.post('/ai/analyze', analyzeTitle);       // 分析单个标题
router.post('/ai/batch-analyze', batchAnalyze); // 批量分析
router.post('/ai/generate', generateTitles);    // 生成标题变体
router.get('/ai/config', getAIConfig);          // 获取AI配置
router.put('/ai/config', updateAIConfig);       // 更新AI配置

module.exports = router;
```

### 3.2 关键API实现

#### 3.2.1 添加标题（单个）

```javascript
/**
 * POST /api/titles
 * Body: {
 *   text: string,
 *   source: string,
 *   category: string,
 *   style: string,
 *   autoAnalyze: boolean  // 是否自动AI分析
 * }
 */
async function addTitle(req, res) {
  const { text, source, category, style, autoAnalyze } = req.body;

  try {
    // 1. 插入标题到SQLite
    const titleId = db.prepare(`
      INSERT INTO titles (text, source, category, style, status)
      VALUES (?, ?, ?, ?, 'pending')
    `).run(text, source, category, style).lastInsertRowid;

    // 2. 如果需要自动分析
    if (autoAnalyze) {
      const analysis = await aiService.analyzeTitle(text);

      // 3. 更新标题分析结果
      db.prepare(`
        UPDATE titles
        SET psychology = ?, core_pattern = ?, confidence = ?,
            status = ?
        WHERE id = ?
      `).run(
        JSON.stringify(analysis.psychology),
        analysis.corePattern,
        analysis.confidence,
        analysis.confidence >= 0.7 ? 'approved' : 'pending',
        titleId
      );

      // 4. 映射元素到元素库
      const mappedElements = await mapElements(analysis.elements);

      // 5. 插入标题-元素关联
      for (const el of mappedElements) {
        db.prepare(`
          INSERT INTO title_elements (title_id, element_id, mechanisms)
          VALUES (?, ?, ?)
        `).run(titleId, el.elementId, JSON.stringify(el.mechanisms));

        // 6. 更新元素使用次数
        db.prepare(`
          UPDATE elements SET usage_count = usage_count + 1
          WHERE id = ?
        `).run(el.elementId);
      }

      // 7. 更新元素搭配关系
      await updateElementPairs(mappedElements.map(e => e.elementId));
    }

    // 8. 生成向量并存储到Qdrant
    const embedding = await aiService.generateEmbedding(text);
    await qdrantClient.upsert('title_embeddings', {
      points: [{
        id: titleId,
        vector: embedding,
        payload: {
          title_id: titleId,
          text: text,
          category: category,
          status: autoAnalyze && analysis.confidence >= 0.7 ? 'approved' : 'pending'
        }
      }]
    });

    res.json({
      code: 0,
      message: '添加成功',
      data: { titleId }
    });

  } catch (error) {
    console.error('添加标题失败:', error);
    res.status(500).json({
      code: 500,
      message: error.message
    });
  }
}
```

#### 3.2.2 语义搜索

```javascript
/**
 * POST /api/titles/search
 * Body: {
 *   query: string,           // 搜索文本
 *   category?: string,       // 领域过滤
 *   status?: string,         // 状态过滤
 *   limit?: number
 * }
 */
async function semanticSearch(req, res) {
  const { query, category, status, limit = 20 } = req.body;

  try {
    // 1. 生成查询向量
    const queryEmbedding = await aiService.generateEmbedding(query);

    // 2. 构建过滤条件
    const filter = { must: [] };
    if (category) {
      filter.must.push({ key: 'category', match: { value: category } });
    }
    if (status) {
      filter.must.push({ key: 'status', match: { value: status } });
    }

    // 3. 向量搜索
    const searchResults = await qdrantClient.search('title_embeddings', {
      vector: queryEmbedding,
      filter: filter.must.length > 0 ? filter : undefined,
      limit: limit,
      with_payload: true,
      with_vector: false
    });

    // 4. 从SQLite获取完整标题信息
    const titleIds = searchResults.map(r => r.id);
    const titles = db.prepare(`
      SELECT t.*,
        GROUP_CONCAT(e.text) as elements
      FROM titles t
      LEFT JOIN title_elements te ON t.id = te.title_id
      LEFT JOIN elements e ON te.element_id = e.id
      WHERE t.id IN (${titleIds.map(() => '?').join(',')})
      GROUP BY t.id
    `).all(...titleIds);

    // 5. 合并向量搜索得分
    const results = titles.map(title => {
      const searchResult = searchResults.find(r => r.id === title.id);
      return {
        ...title,
        similarity: searchResult.score,  // 相似度得分
        psychology: JSON.parse(title.psychology || '[]'),
        elements: title.elements ? title.elements.split(',') : []
      };
    });

    res.json({
      code: 0,
      data: results
    });

  } catch (error) {
    console.error('语义搜索失败:', error);
    res.status(500).json({
      code: 500,
      message: error.message
    });
  }
}
```

#### 3.2.3 批量分析（队列处理）

```javascript
/**
 * POST /api/ai/batch-analyze
 * Body: {
 *   titleIds: number[]
 * }
 */
const analysisQueue = [];
let isProcessing = false;

async function batchAnalyze(req, res) {
  const { titleIds } = req.body;

  // 1. 添加到队列
  const jobId = Date.now();
  analysisQueue.push({
    jobId,
    titleIds,
    status: 'pending',
    progress: 0,
    total: titleIds.length
  });

  // 2. 立即返回任务ID
  res.json({
    code: 0,
    message: '批量分析任务已创建',
    data: { jobId }
  });

  // 3. 异步处理队列
  processQueue();
}

async function processQueue() {
  if (isProcessing) return;

  isProcessing = true;

  while (analysisQueue.length > 0) {
    const job = analysisQueue[0];
    job.status = 'processing';

    for (let i = 0; i < job.titleIds.length; i++) {
      const titleId = job.titleIds[i];

      try {
        // 获取标题
        const title = db.prepare('SELECT * FROM titles WHERE id = ?').get(titleId);

        // AI分析
        const analysis = await aiService.analyzeTitle(title.text);

        // 更新数据库（同单个添加逻辑）
        // ...

        job.progress = i + 1;

        // 控制并发（最多5个同时）
        if (i % 5 === 0 && i > 0) {
          await new Promise(resolve => setTimeout(resolve, 1000));
        }

      } catch (error) {
        console.error(`分析标题${titleId}失败:`, error);
      }
    }

    job.status = 'completed';
    analysisQueue.shift();
  }

  isProcessing = false;
}

// 查询批量任务进度
router.get('/ai/batch-status/:jobId', (req, res) => {
  const { jobId } = req.params;
  const job = analysisQueue.find(j => j.jobId == jobId);

  res.json({
    code: 0,
    data: job || { status: 'not_found' }
  });
});
```

---

## 四、AI服务封装

### 4.1 服务类设计

```javascript
// server/services/ai-service.js
class AIService {
  constructor() {
    this.config = this.loadConfig();
  }

  loadConfig() {
    const config = db.prepare('SELECT * FROM ai_config WHERE id = 1').get();
    return config || {
      provider: 'deepseek',
      api_key: process.env.DEEPSEEK_API_KEY,
      endpoint: 'https://api.deepseek.com/v1',
      model: 'deepseek-chat',
      embedding_provider: 'openai',
      embedding_api_key: process.env.OPENAI_API_KEY,
      embedding_model: 'text-embedding-3-small'
    };
  }

  /**
   * 分析标题
   */
  async analyzeTitle(titleText) {
    const prompt = this.buildAnalysisPrompt(titleText);

    const response = await this.callLLM(prompt);
    const result = JSON.parse(response);

    // 验证结果格式
    this.validateAnalysisResult(result);

    return result;
  }

  buildAnalysisPrompt(titleText) {
    return `你是爆款标题分析专家。分析以下标题的点击心理和可复用元素。

标题: ${titleText}

返回JSON格式:
{
  "psychology": [
    "\"3个方法\"降低认知成本,让人觉得简单可学",
    "\"快速\"刺激焦虑和欲望,暗示短时间见效"
  ],
  "elements": [
    {
      "text": "3个方法",
      "standardized": "N个方法",
      "category": "降低门槛",
      "mechanisms": ["数字降低门槛", "具体可操作"]
    }
  ],
  "corePattern": "数字降门槛 + 速度刺激",
  "confidence": 0.85
}

已有元素参考（优先匹配）:
${this.getExistingElements()}`;
  }

  getExistingElements() {
    const elements = db.prepare(`
      SELECT text, category FROM elements
      ORDER BY usage_count DESC LIMIT 20
    `).all();

    return elements.map(e => `- "${e.text}" (${e.category})`).join('\n');
  }

  /**
   * 调用LLM
   */
  async callLLM(prompt) {
    const { provider, api_key, endpoint, model } = this.config;

    if (provider === 'deepseek' || provider === 'openai') {
      return this.callOpenAICompatible(endpoint, api_key, model, prompt);
    } else if (provider === 'claude') {
      return this.callClaude(api_key, model, prompt);
    }
  }

  async callOpenAICompatible(endpoint, apiKey, model, prompt) {
    const response = await fetch(`${endpoint}/chat/completions`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`
      },
      body: JSON.stringify({
        model: model,
        messages: [{ role: 'user', content: prompt }],
        temperature: 0.3,
        response_format: { type: 'json_object' }
      })
    });

    const data = await response.json();
    return data.choices[0].message.content;
  }

  /**
   * 生成Embedding
   */
  async generateEmbedding(text) {
    const { embedding_provider, embedding_api_key, embedding_model } = this.config;

    if (embedding_provider === 'openai') {
      const response = await fetch('https://api.openai.com/v1/embeddings', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${embedding_api_key}`
        },
        body: JSON.stringify({
          model: embedding_model,
          input: text
        })
      });

      const data = await response.json();
      return data.data[0].embedding;
    }
  }

  /**
   * 降级到规则引擎
   */
  fallbackAnalysis(titleText) {
    const elements = [];

    // 数字检测
    const numbers = titleText.match(/\d+/g);
    if (numbers) {
      elements.push({
        text: numbers[0] + '个',
        standardized: 'N个',
        category: '降低门槛',
        mechanisms: ['数字降低门槛']
      });
    }

    // 速度词检测
    const speedWords = ['快速', '极速', '秒懂', '立即'];
    for (const word of speedWords) {
      if (titleText.includes(word)) {
        elements.push({
          text: word,
          standardized: word,
          category: '制造紧迫感',
          mechanisms: ['速度刺激']
        });
      }
    }

    return {
      psychology: ['检测到数字和速度词'],
      elements: elements,
      corePattern: '规则引擎分析',
      confidence: 0.3
    };
  }
}

module.exports = new AIService();
```

---

## 五、前端实现

### 5.1 页面路由

```tsx
// src/App.tsx 添加路由
import TitleLibrary from './pages/TitleLibrary';
import ElementLibrary from './pages/ElementLibrary';
import AISettings from './pages/AISettings';

const menuItems = [
  // ... 现有菜单
  {
    key: 'knowledge',
    icon: <BookOutlined />,
    label: '知识库',
    children: [
      { key: 'title-library', label: '标题库' },
      { key: 'element-library', label: '元素库' },
    ],
  },
  {
    key: 'settings',
    icon: <SettingOutlined />,
    label: '设置',
    children: [
      { key: 'ai-settings', label: 'AI配置' },
    ],
  },
];

const renderContent = () => {
  switch (selectedKey) {
    case 'title-library':
      return <TitleLibrary />;
    case 'element-library':
      return <ElementLibrary />;
    case 'ai-settings':
      return <AISettings />;
    // ...
  }
};
```

### 5.2 标题库页面（核心）

```tsx
// src/pages/TitleLibrary.tsx
import React, { useState, useEffect } from 'react';
import { Table, Button, Input, Select, Tag, Modal, message } from 'antd';
import { searchTitles, addTitle, approveTitle } from '@/api/titles';
import AddTitleModal from '@/components/AddTitleModal';

const TitleLibrary: React.FC = () => {
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');
  const [filters, setFilters] = useState({
    status: 'all',
    category: 'all'
  });
  const [showAddModal, setShowAddModal] = useState(false);

  // 语义搜索
  const handleSearch = async () => {
    if (!searchQuery.trim()) {
      message.warning('请输入搜索内容');
      return;
    }

    setLoading(true);
    try {
      const response = await searchTitles({
        query: searchQuery,
        category: filters.category === 'all' ? undefined : filters.category,
        status: filters.status === 'all' ? undefined : filters.status
      });

      setData(response.data);
    } catch (error) {
      message.error('搜索失败');
    } finally {
      setLoading(false);
    }
  };

  const columns = [
    {
      title: '标题',
      dataIndex: 'text',
      width: '30%',
      render: (text, record) => (
        <div>
          <div>{text}</div>
          {record.similarity && (
            <Tag color="blue">相似度: {(record.similarity * 100).toFixed(1)}%</Tag>
          )}
        </div>
      )
    },
    {
      title: '心理分析',
      dataIndex: 'psychology',
      width: '35%',
      render: (psychology) => (
        <div>
          {psychology.slice(0, 3).map((p, i) => (
            <div key={i} style={{ fontSize: 12, marginBottom: 4 }}>{p}</div>
          ))}
        </div>
      )
    },
    {
      title: '核心套路',
      dataIndex: 'core_pattern',
      width: '15%'
    },
    {
      title: '状态',
      dataIndex: 'status',
      width: '10%',
      render: (status) => (
        <Tag color={status === 'approved' ? 'green' : 'orange'}>
          {status === 'approved' ? '已通过' : '待审核'}
        </Tag>
      )
    },
    {
      title: '操作',
      width: '10%',
      render: (_, record) => (
        <Button size="small" onClick={() => handleApprove(record.id)}>
          审核
        </Button>
      )
    }
  ];

  return (
    <div>
      <div style={{ marginBottom: 16, display: 'flex', gap: 8 }}>
        <Input.Search
          placeholder="输入标题内容进行语义搜索..."
          value={searchQuery}
          onChange={e => setSearchQuery(e.target.value)}
          onSearch={handleSearch}
          style={{ width: 400 }}
        />
        <Select
          value={filters.status}
          onChange={v => setFilters({...filters, status: v})}
          style={{ width: 120 }}
        >
          <Select.Option value="all">全部状态</Select.Option>
          <Select.Option value="pending">待审核</Select.Option>
          <Select.Option value="approved">已通过</Select.Option>
        </Select>
        <Button type="primary" onClick={() => setShowAddModal(true)}>
          添加标题
        </Button>
      </div>

      <Table
        columns={columns}
        dataSource={data}
        loading={loading}
        rowKey="id"
      />

      <AddTitleModal
        visible={showAddModal}
        onClose={() => setShowAddModal(false)}
        onSuccess={loadData}
      />
    </div>
  );
};
```

### 5.3 添加标题模态框（关键组件）

```tsx
// src/components/AddTitleModal.tsx
import React, { useState } from 'react';
import { Modal, Input, Select, Button, Spin } from 'antd';
import { addTitle } from '@/api/titles';

const AddTitleModal: React.FC<Props> = ({ visible, onClose, onSuccess }) => {
  const [form, setForm] = useState({
    text: '',
    source: '',
    category: '',
    style: ''
  });
  const [analyzing, setAnalyzing] = useState(false);
  const [analysisResult, setAnalysisResult] = useState(null);

  const handleAnalyze = async () => {
    setAnalyzing(true);
    try {
      const response = await addTitle({
        ...form,
        autoAnalyze: true
      });

      setAnalysisResult(response.data);
      message.success('AI分析完成');
    } catch (error) {
      message.error('分析失败');
    } finally {
      setAnalyzing(false);
    }
  };

  return (
    <Modal
      title="添加标题"
      open={visible}
      onCancel={onClose}
      footer={null}
      width={800}
    >
      <Input.TextArea
        placeholder="输入标题..."
        value={form.text}
        onChange={e => setForm({...form, text: e.target.value})}
        rows={3}
      />

      <div style={{ marginTop: 16, display: 'flex', gap: 8 }}>
        <Input
          placeholder="来源"
          value={form.source}
          onChange={e => setForm({...form, source: e.target.value})}
        />
        <Select
          placeholder="领域"
          value={form.category}
          onChange={v => setForm({...form, category: v})}
          style={{ width: 150 }}
        >
          <Select.Option value="自媒体">自媒体</Select.Option>
          <Select.Option value="科技">科技</Select.Option>
        </Select>
      </div>

      <Button
        type="primary"
        onClick={handleAnalyze}
        loading={analyzing}
        style={{ marginTop: 16 }}
      >
        AI分析
      </Button>

      {analysisResult && (
        <div style={{ marginTop: 16, border: '1px solid #d9d9d9', padding: 16 }}>
          <h4>分析结果</h4>
          <div>置信度: {(analysisResult.confidence * 100).toFixed(0)}%</div>
          <div>心理分析: {analysisResult.psychology.join('; ')}</div>
          <div>核心套路: {analysisResult.corePattern}</div>
        </div>
      )}
    </Modal>
  );
};
```

---

## 六、部署方案

### 6.1 开发环境

```yaml
# docker-compose.yml
version: '3.8'

services:
  qdrant:
    image: qdrant/qdrant:latest
    ports:
      - "6333:6333"
    volumes:
      - ./qdrant_storage:/qdrant/storage
```

```bash
# 启动
docker-compose up -d

# 验证
curl http://localhost:6333/collections
```

### 6.2 package.json脚本

```json
{
  "scripts": {
    "dev": "vite",
    "server": "node server/index.cjs",
    "title-server": "node server/title-api.cjs",
    "start": "concurrently \"npm run dev\" \"npm run server\" \"npm run title-server\"",
    "init-db": "node scripts/init-database.js"
  }
}
```

### 6.3 数据库初始化脚本

```javascript
// scripts/init-database.js
const Database = require('better-sqlite3');
const fs = require('fs');

const db = new Database('data/titles.db');

// 读取schema
const schema = fs.readFileSync('server/schema.sql', 'utf8');

// 执行
db.exec(schema);

// 插入预置元素
const seedElements = [
  { text: 'N个方法', category: '降低门槛', explanation: '数字降低认知成本' },
  { text: '快速', category: '制造紧迫感', explanation: '速度词刺激焦虑' },
  // ... 更多
];

const insert = db.prepare(`
  INSERT INTO elements (text, category, explanation)
  VALUES (?, ?, ?)
`);

for (const el of seedElements) {
  insert.run(el.text, el.category, el.explanation);
}

console.log('✓ 数据库初始化完成');
```

---

## 七、关键问题解决方案

### 7.1 向量搜索 + 关键词结合

```javascript
// 混合搜索策略
async function hybridSearch(query, filters) {
  // 1. 向量搜索（语义相似）
  const vectorResults = await semanticSearch(query, filters, 50);

  // 2. 关键词搜索（精确匹配）
  const keywordResults = db.prepare(`
    SELECT * FROM titles
    WHERE text LIKE ?
    ${filters.category ? 'AND category = ?' : ''}
    LIMIT 20
  `).all(`%${query}%`, filters.category);

  // 3. 合并去重（向量结果优先）
  const merged = [...vectorResults];
  for (const kr of keywordResults) {
    if (!merged.find(vr => vr.id === kr.id)) {
      merged.push({...kr, similarity: 0.5}); // 关键词匹配给固定分
    }
  }

  // 4. 按相似度排序
  return merged.sort((a, b) => b.similarity - a.similarity).slice(0, 20);
}
```

### 7.2 AI调用成本控制

```javascript
// 1. 缓存策略
const analysisCache = new Map();

async function analyzeWithCache(titleText) {
  const cacheKey = titleText.trim().toLowerCase();

  if (analysisCache.has(cacheKey)) {
    return analysisCache.get(cacheKey);
  }

  const result = await aiService.analyzeTitle(titleText);
  analysisCache.set(cacheKey, result);

  return result;
}

// 2. 批量处理限流
const pLimit = require('p-limit');
const limit = pLimit(5); // 最多5个并发

async function batchAnalyzeWithLimit(titleTexts) {
  const tasks = titleTexts.map(text =>
    limit(() => aiService.analyzeTitle(text))
  );

  return Promise.all(tasks);
}
```

### 7.3 数据迁移方案

```javascript
// 从原型HTML迁移到数据库
async function migrateFromPrototype() {
  const prototypeData = [
    { text: '3个方法让你快速涨粉10万', source: '今日头条', ... },
    // ...
  ];

  for (const item of prototypeData) {
    await addTitle(item);
  }
}
```

---

## 八、完成标准

1. ✅ 支持单个标题添加 + AI自动分析
2. ✅ 支持批量导入CSV + 队列处理
3. ✅ 语义搜索正常工作（Qdrant）
4. ✅ 元素库正常管理
5. ✅ 元素搭配关系自动更新
6. ✅ AI配置页面可切换API
7. ✅ 前端页面复用原型CSS样式

---

**预计开发周期: 7-10天**

- Day 1-2: 后端API + 数据库
- Day 3-4: Qdrant集成 + AI服务
- Day 5-6: 前端页面开发
- Day 7: 测试 + 优化
