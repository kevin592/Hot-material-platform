# 微信指数自动化采集系统 - 完整方案

## 项目目标

自动采集微信指数数据 → 存入数据库 → 为内容创作提供数据支持

---

## 系统架构

```
┌─────────────────────────────────────────────────┐
│  前端界面 - "更新数据"按钮                       │
└─────────────────┬───────────────────────────────┘
                  ↓
┌─────────────────────────────────────────────────┐
│  后端API接口 (/api/update-index)                │
└─────────────────┬───────────────────────────────┘
                  ↓
┌─────────────────────────────────────────────────┐
│  异步任务队列 (后台执行)                         │
└─────────────────┬───────────────────────────────┘
                  ↓
┌─────────────────────────────────────────────────┐
│  Step 1: ADB自动化控制模拟器                     │
│  - 启动雷电/夜神模拟器                           │
│  - 打开微信                                      │
│  - 点击打开"微信指数"小程序                      │
└─────────────────┬───────────────────────────────┘
                  ↓
┌─────────────────────────────────────────────────┐
│  Step 2: mitmproxy抓包                          │
│  - 模拟器流量经过mitmproxy代理                   │
│  - 自动截获微信指数API请求                       │
│  - 提取 openid 和 search_key                    │
└─────────────────┬───────────────────────────────┘
                  ↓
┌─────────────────────────────────────────────────┐
│  Step 3: 批量采集关键词数据                      │
│  - 读取关键词列表(从配置文件/数据库)             │
│  - 循环调用微信指数API                           │
│  - 获取每个关键词的90天数据                      │
└─────────────────┬───────────────────────────────┘
                  ↓
┌─────────────────────────────────────────────────┐
│  Step 4: 数据存储到数据库                        │
│  - 去重(避免重复插入)                            │
│  - 保存到MySQL/PostgreSQL                       │
│  - 记录采集日志                                  │
└─────────────────┬───────────────────────────────┘
                  ↓
┌─────────────────────────────────────────────────┐
│  Step 5: WebSocket实时推送进度                   │
│  - 前端显示进度条                                │
│  - 实时日志输出                                  │
│  - 完成后通知用户                                │
└─────────────────────────────────────────────────┘
```

---

## 技术栈选择

### 1. 模拟器
- **雷电模拟器** 或 **夜神模拟器** (推荐雷电,更稳定)
- 原因: 支持ADB命令控制
- 下载: https://www.ldmnq.com/

### 2. 自动化工具
- **ADB** (Android Debug Bridge) - 控制模拟器
- **uiautomator2** (Python库) - UI自动化
  ```bash
  pip install uiautomator2
  ```
- 或者 **appium** (更重量级,但功能强大)

### 3. 抓包工具
- **mitmproxy** (Python编写,可编程)
  ```bash
  pip install mitmproxy
  ```
- 可以写脚本自动提取参数

### 4. 数据库
- **MySQL** 或 **PostgreSQL** (推荐PG,数据分析更强)
- 或 **SQLite** (如果数据量不大)

### 5. 后端服务
- **Python FastAPI** (推荐,现代化,支持异步)
  ```bash
  pip install fastapi uvicorn
  ```
- 或 **Node.js Express** (如果你前端是JS栈)

### 6. 任务队列
- **Celery** (Python异步任务)
- 或 **APScheduler** (更轻量)
- 或 **Bull** (Node.js)

### 7. 实时通信
- **WebSocket** (前后端实时通信)
- FastAPI内置支持

---

## 数据库设计

### 表结构

```sql
-- 关键词表
CREATE TABLE keywords (
    id SERIAL PRIMARY KEY,
    keyword VARCHAR(100) UNIQUE NOT NULL,
    category VARCHAR(50),  -- 分类:科技/娱乐/财经等
    status BOOLEAN DEFAULT TRUE,  -- 是否启用监控
    created_at TIMESTAMP DEFAULT NOW()
);

-- 微信指数数据表
CREATE TABLE wechat_index_data (
    id SERIAL PRIMARY KEY,
    keyword_id INT REFERENCES keywords(id),
    date DATE NOT NULL,
    index_value BIGINT,  -- 指数值
    created_at TIMESTAMP DEFAULT NOW(),
    UNIQUE(keyword_id, date)  -- 防止重复
);

-- 趋势分析表(预计算,提升查询速度)
CREATE TABLE keyword_trends (
    id SERIAL PRIMARY KEY,
    keyword_id INT REFERENCES keywords(id),
    avg_7days BIGINT,  -- 7日平均
    avg_30days BIGINT,  -- 30日平均
    growth_rate FLOAT,  -- 增长率
    heat_rank INT,  -- 热度排名
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 采集日志表
CREATE TABLE crawl_logs (
    id SERIAL PRIMARY KEY,
    start_time TIMESTAMP,
    end_time TIMESTAMP,
    status VARCHAR(20),  -- success/failed/running
    keywords_count INT,
    error_message TEXT,
    created_at TIMESTAMP DEFAULT NOW()
);

-- 创作建议表
CREATE TABLE writing_suggestions (
    id SERIAL PRIMARY KEY,
    keyword_id INT REFERENCES keywords(id),
    suggestion_type VARCHAR(50),  -- 选题建议/优化方向/热点预警
    content TEXT,
    score FLOAT,  -- 建议评分
    created_at TIMESTAMP DEFAULT NOW()
);
```

---

## 实现方案对比

### 方案1: 完全自动化 ✅ 推荐(长期使用)

**特点**:
- 点击按钮,全自动完成所有操作
- 或者设置定时任务,每天自动运行

**流程**:
```
用户点击"更新数据"按钮
    ↓
后端异步任务启动:
    1. 启动雷电模拟器 (20-30秒)
    2. 启动mitmproxy代理
    3. 打开微信 (5-10秒)
    4. 自动点击 → 打开微信指数小程序 (5秒)
    5. 抓取search_key (2-3秒)
    6. 批量采集关键词数据 (100个关键词约150秒)
    7. 存入数据库
    8. 关闭模拟器
    ↓
总耗时: 3-4分钟
前端显示: 进度条 + 实时日志
```

**初始配置**(一次性):
1. 安装雷电模拟器
2. 在模拟器上登录微信(扫码)
3. 配置mitmproxy证书
4. 测试自动化流程

**配置耗时**: 30分钟

**优点**:
- ✅ 完全自动化,无需人工干预
- ✅ 可以设置定时任务
- ✅ 适合长期使用

**缺点**:
- ❌ 初始配置稍复杂
- ❌ 每次运行耗时3-4分钟
- ❌ 模拟器占用资源(如果常驻)

---

### 方案2: 半自动化 (更稳定)

**特点**:
- 模拟器保持开启,微信保持登录
- 点击按钮只做: 打开小程序 → 抓包 → 采集

**流程**:
```
模拟器常驻(微信已登录)
    ↓
用户点击"更新数据"
    ↓
后端:
    1. 自动打开微信指数小程序 (5秒)
    2. 抓包获取search_key (2秒)
    3. 批量采集数据 (150秒)
    4. 存入数据库
    ↓
总耗时: 1-2分钟
```

**资源占用**:
- 模拟器常驻: 2-4GB内存

**优点**:
- ✅ 速度快(省去启动时间)
- ✅ 更稳定(微信保持登录)

**缺点**:
- ❌ 占用内存
- ❌ 需要模拟器一直开着

---

### 方案3: 最简方案 (最稳妥)

**特点**:
- 手动打开微信指数,自动抓包和采集

**流程**:
```
1. 模拟器开着,微信已登录
2. mitmproxy后台运行
3. 用户手动在模拟器上打开微信指数 (10秒)
4. 点击前端"更新数据"按钮
5. 自动采集所有关键词 (2分钟)
```

**优点**:
- ✅ 最稳定
- ✅ 不依赖UI自动化
- ✅ 不容易出错

**缺点**:
- ❌ 需要手动操作10秒

---

## 核心技术实现

### 1. ADB控制模拟器

```python
import subprocess

# 启动模拟器
def start_emulator():
    subprocess.run(['adb', 'devices'])  # 检测设备

# 启动微信
def start_wechat():
    subprocess.run([
        'adb', 'shell', 'am', 'start',
        '-n', 'com.tencent.mm/.ui.LauncherUI'
    ])

# 模拟点击
def click(x, y):
    subprocess.run(['adb', 'shell', 'input', 'tap', str(x), str(y)])

# 输入文本
def input_text(text):
    subprocess.run(['adb', 'shell', 'input', 'text', text])
```

### 2. mitmproxy自动抓包

```python
# mitm_addon.py
from mitmproxy import http
import json

class WeChatIndexSniffer:
    def __init__(self):
        self.search_key = None
        self.openid = None

    def request(self, flow: http.HTTPFlow):
        # 检测微信指数API
        if "querywxindexgroup" in flow.request.url:
            params = dict(flow.request.query)
            self.openid = params.get('openid')
            self.search_key = params.get('search_key')

            # 保存到文件
            with open('credentials.json', 'w') as f:
                json.dump({
                    'openid': self.openid,
                    'search_key': self.search_key
                }, f)

            print(f"✅ 已捕获: openid={self.openid}, search_key={self.search_key}")

addons = [WeChatIndexSniffer()]
```

启动方式:
```bash
mitmdump -s mitm_addon.py --listen-host 0.0.0.0 --listen-port 8888
```

### 3. UI自动化 (uiautomator2)

```python
import uiautomator2 as u2

# 连接模拟器
d = u2.connect('127.0.0.1:5555')

# 打开微信
d.app_start("com.tencent.mm")

# 点击搜索框
d(resourceId="com.tencent.mm:id/cd7").click()

# 输入"微信指数"
d(resourceId="com.tencent.mm:id/cd8").set_text("微信指数")

# 点击小程序
d(text="微信指数").click()
```

### 4. 后端API (FastAPI)

```python
from fastapi import FastAPI, WebSocket
from fastapi.responses import JSONResponse
import asyncio

app = FastAPI()

@app.post("/api/update-index")
async def update_index():
    # 创建异步任务
    asyncio.create_task(run_crawler_task())
    return {"status": "started", "message": "数据采集任务已启动"}

async def run_crawler_task():
    # 1. 启动模拟器
    # 2. 打开微信
    # 3. 抓包
    # 4. 采集数据
    # 5. 存入数据库
    pass

@app.websocket("/ws/progress")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    # 实时推送进度
    await websocket.send_json({"progress": 30, "message": "正在启动模拟器..."})
```

---

## 时间成本评估

### 完全自动化方案
- **初始配置**: 30分钟 (一次性)
- **开发时间**:
  - ADB自动化: 2-3天
  - mitmproxy抓包: 1天
  - 数据采集: 1天
  - 数据库设计: 0.5天
  - 后端API: 1-2天
  - 前端界面: 2-3天
  - 测试调试: 2天
  - **总计**: 10-14天

### 半自动化方案
- **初始配置**: 20分钟
- **开发时间**:
  - 基础自动化: 1-2天
  - 数据采集: 1天
  - 后端API: 1天
  - 前端界面: 2天
  - **总计**: 5-6天

### 最简方案
- **初始配置**: 10分钟
- **开发时间**:
  - 抓包脚本: 0.5天
  - 数据采集: 1天
  - 后端API: 1天
  - 前端界面: 1-2天
  - **总计**: 3-4天

---

## 风险评估

### 技术风险

| 风险项 | 风险等级 | 解决方案 |
|--------|---------|---------|
| 模拟器登录微信被封号 | 中 | 使用小号,降低操作频率 |
| search_key过期 | 低 | 每天重新抓包 |
| 微信更新导致UI变化 | 中 | 定期维护自动化脚本 |
| 抓包被检测 | 低 | 使用系统级代理,不修改请求 |
| 模拟器启动失败 | 低 | 添加重试机制 |
| 网络请求失败 | 低 | 添加重试和异常处理 |

### 运维风险

| 风险项 | 风险等级 | 解决方案 |
|--------|---------|---------|
| 长期运行稳定性 | 中 | 添加监控和自动恢复 |
| 数据库容量增长 | 低 | 定期归档历史数据 |
| 服务器资源占用 | 中 | 优化模拟器启动策略 |

---

## 为创作提供的功能

### 1. 热点发现
- 检测指数突然上涨的关键词(增长率>50%)
- 推送热点选题建议
- 示例: "ChatGPT指数7天上涨300%,建议立即创作相关内容"

### 2. 趋势预测
- 基于历史数据预测未来7天趋势
- 识别长期上升/下降趋势
- 示例: "人工智能指数持续30天上涨,预计未来7天继续增长"

### 3. 关键词组合建议
- 分析高热度关键词组合
- 生成SEO友好的标题建议
- 示例: "AI+创作"组合热度高,建议标题: "AI如何赋能内容创作"

### 4. 最佳发布时机
- 分析指数波动规律
- 建议最佳发布时间
- 示例: "该关键词每周三热度最高,建议周三上午发布"

### 5. 竞品分析
- 对比多个相关关键词
- 找出蓝海关键词(搜索量高但竞争小)

---

## 待确认的问题

### 硬件配置
1. **电脑内存多大?**
   - >=16GB → 模拟器可以常驻
   - <=8GB → 建议按需启动

2. **操作系统**: Windows (已确认)

### 使用场景
3. **更新频率**:
   - 每天手动点按钮?
   - 还是定时自动运行?

4. **关键词数量**:
   - 目前有多少个?
   - 预计增长到多少?

### 技术选型
5. **前端框架**:
   - React / Vue / Electron / 纯HTML?

6. **后端语言**:
   - Python (FastAPI) ?
   - Node.js (Express) ?

7. **数据库**:
   - MySQL / PostgreSQL / SQLite?

---

## 推荐方案

### 如果是公司项目/长期使用
→ **方案1: 完全自动化**
- 初期投入大,长期省心
- 适合每天自动定时运行

### 如果是个人项目/偶尔使用
→ **方案2: 半自动化**
- 模拟器常驻,点击即用
- 快速稳定

### 如果想快速上线测试
→ **方案3: 最简方案**
- 开发周期最短
- 验证可行性后再优化

---

## 下一步行动

1. **确认上述"待确认的问题"**
2. **选择实现方案**(方案1/2/3)
3. **开始开发**:
   - 先实现MVP(最小可用版本)
   - 再逐步完善功能
   - 最后优化用户体验

---

*文档创建时间: 2025-10-23*
*项目代码路径: F:\AI\hot-material-platform*
