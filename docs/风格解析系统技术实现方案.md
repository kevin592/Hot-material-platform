# 作者风格解析系统技术实现方案

## 项目概述

基于现有的200多篇文章数据，实现作者写作风格的自动化解析和量化分析。采用LLM+本地分析+分层JSON的混合架构，在现有技术栈基础上增量开发。

## 现有技术栈分析

### 前端架构
- **React + TypeScript + Vite** - 现代化前端框架
- **Ant Design** - 组件库，便于快速开发
- **现有页面结构**：热点内容发现、编辑器页面

### 后端架构
- **Express + Node.js** - 轻量级后端
- **SQLite** (server/style-analysis.db) - 已有数据库
- **现有功能**：文件上传、图片处理、热点搜索代理

## 技术实现方案

### 方案架构图
```
文章上传 → 文本预处理 → DeepSeek风格分析 → 本地模式匹配 → 风格指纹生成 → 前端展示
```

### 1. 数据库设计扩展

```sql
-- 作者表
CREATE TABLE authors (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  description TEXT,
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  article_count INTEGER DEFAULT 0
);

-- 文章表
CREATE TABLE articles (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  author_id TEXT NOT NULL,
  title TEXT NOT NULL,
  content TEXT NOT NULL,
  word_count INTEGER,
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (author_id) REFERENCES authors(id)
);

-- 风格分析结果表
CREATE TABLE style_analyses (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  article_id INTEGER NOT NULL,
  author_id TEXT NOT NULL,
  analysis_result TEXT NOT NULL, -- JSON格式
  analysis_version TEXT DEFAULT '1.0',
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (article_id) REFERENCES articles(id),
  FOREIGN KEY (author_id) REFERENCES authors(id)
);

-- 作者风格指纹表
CREATE TABLE author_fingerprints (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  author_id TEXT NOT NULL,
  fingerprint_data TEXT NOT NULL, -- JSON格式
  article_count INTEGER NOT NULL,
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  updated_at TEXT DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (author_id) REFERENCES authors(id)
);
```

### 2. 后端API设计 (server/api/style-analysis.js)

```javascript
const express = require('express');
const sqlite3 = require('better-sqlite3');
const router = express.Router();

// 数据库连接
const db = new sqlite3('./server/style-analysis.db');

// 1. 创建作者
router.post('/authors', async (req, res) => {
  const { name, description } = req.body;
  const authorId = `author_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

  db.prepare(`
    INSERT INTO authors (id, name, description)
    VALUES (?, ?, ?)
  `).run(authorId, name, description);

  res.json({ success: true, authorId });
});

// 2. 上传文章
router.post('/articles', async (req, res) => {
  const { authorId, title, content } = req.body;

  // 保存文章
  const result = db.prepare(`
    INSERT INTO articles (author_id, title, content, word_count)
    VALUES (?, ?, ?, ?)
  `).run(authorId, title, content, content.length);

  // 异步触发风格分析
  analyzeArticleAsync(result.lastInsertRowid, content, authorId);

  res.json({
    success: true,
    articleId: result.lastInsertRowid
  });
});

// 3. DeepSeek API配置
const DEEPSEEK_CONFIG = {
  apiKey: process.env.DEEPSEEK_API_KEY,
  baseURL: 'https://api.deepseek.com/v1',
  model: 'deepseek-chat'
};

// 4. DeepSeek风格分析（核心算法）
async function analyzeStyleWithDeepSeek(content) {
  const prompt = `
你是一位专业的中文写作风格分析师。请深度分析以下文章，提取作者的个人写作风格特征。

分析要求：
1. 识别口语化表达习惯（转折词、强调词等）
2. 分析句式特征（开头、转折、结尾模式）
3. 检测金句和表达技巧
4. 分析情绪节奏和论证逻辑
5. 统计关键数据（词频、句长等）

请以严格的JSON格式返回结果：

{
  "口语化特征": {
    "转折词类": {
      "词汇": ["可倒好", "偏偏", "结果呢"],
      "使用频率": "每千字X次",
      "典型语境": ["反驳对比", "意外转折"],
      "真实例句": ["具体例句1", "具体例句2"]
    },
    "强调词类": {
      "词汇": ["压根", "完全", "根本"],
      "使用频率": "每千字Y次",
      "典型语境": ["强烈肯定", "否定反驳"],
      "真实例句": ["具体例句1", "具体例句2"]
    }
  },
  "句式特征": {
    "开头偏好": {
      "模式": ["有意思的是", "问题是"],
      "使用频率": "开头段X%使用"
    },
    "转折习惯": {
      "模式": ["正常情况A，但偏偏B"],
      "使用频率": "每篇X次"
    },
    "收尾习惯": {
      "模式": ["升华总结", "反问结尾"],
      "使用频率": "结尾段X%使用"
    }
  },
  "写作技巧": {
    "金句识别": {
      "数量": X,
      "类型": ["对比式", "判断式", "反问式"],
      "位置偏好": ["段末", "高潮段"],
      "典型金句": ["金句1", "金句2"]
    },
    "论证手法": {
      "主要方式": ["数据支撑", "案例对比", "逻辑推理"],
      "数据使用": "每千字X个数字",
      "案例特点": ["极端对比", "历史类比"]
    }
  },
  "情绪节奏": {
    "引入段": X,
    "论证段": Y,
    "高潮段": Z,
    "结尾段": W,
    "整体模式": "递进式/平稳式/爆发式"
  },
  "量化指标": {
    "总字数": X,
    "段落数": Y,
    "平均句长": Z,
    "口语化程度": X/10,
    "讽刺力度": Y/10,
    "金句密度": "每千字Z个"
  }
}

文章内容：
${content.substring(0, 8000)} // 限制字数避免超长
`;

  try {
    const response = await fetch(`${DEEPSEEK_CONFIG.baseURL}/chat/completions`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${DEEPSEEK_CONFIG.apiKey}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        model: DEEPSEEK_CONFIG.model,
        messages: [
          {
            role: 'system',
            content: '你是一位专业的中文写作风格分析师，擅长从文章中提取作者的个人写作风格特征。'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        temperature: 0.3,
        max_tokens: 4000
      })
    });

    const result = await response.json();
    const analysisText = result.choices[0].message.content;

    // 解析JSON结果
    const analysisResult = JSON.parse(analysisText);
    return validateAndCleanAnalysis(analysisResult);

  } catch (error) {
    console.error('DeepSeek API调用失败:', error);
    return getFallbackAnalysis(content);
  }
}

// 5. 验证和清理分析结果
function validateAndCleanAnalysis(analysis) {
  // 验证必要字段
  const requiredFields = ['口语化特征', '句式特征', '写作技巧', '情绪节奏', '量化指标'];

  for (const field of requiredFields) {
    if (!analysis[field]) {
      analysis[field] = getDefaultValueForField(field);
    }
  }

  // 清理和标准化数据
  analysis.量化指标.口语化程度 = Math.min(10, Math.max(0, analysis.量化指标.口语化程度 || 0));
  analysis.量化指标.讽刺力度 = Math.min(10, Math.max(0, analysis.量化指标.讽刺力度 || 0));

  return analysis;
}

// 6. 获取默认分析结果（降级方案）
function getFallbackAnalysis(content) {
  const wordCount = content.length;
  const sentenceCount = content.split(/[。！？]/).length;
  const avgSentenceLength = Math.round(wordCount / sentenceCount);

  return {
    口语化特征: {
      转折词类: {
        词汇: [],
        使用频率: "每千字0次",
        典型语境: [],
        真实例句: []
      }
    },
    句式特征: {
      开头偏好: {
        模式: [],
        使用频率: "0%"
      }
    },
    写作技巧: {
      金句识别: {
        数量: 0,
        类型: [],
        位置偏好: [],
        典型金句: []
      }
    },
    情绪节奏: {
      引入段: 5,
      论证段: 7,
      高潮段: 8,
      结尾段: 6,
      整体模式: "平稳式"
    },
    量化指标: {
      总字数: wordCount,
      段落数: content.split('\n\n').length,
      平均句长: avgSentenceLength,
      口语化程度: 5,
      讽刺力度: 5,
      金句密度: "每千字0个"
    }
  };
}

module.exports = router;
```

### 3. 前端组件设计 (TypeScript)

```typescript
// src/types/style-analysis.ts

export interface Author {
  id: string;
  name: string;
  description?: string;
  articleCount: number;
  createdAt: string;
}

export interface StyleAnalysis {
  口语化特征: {
    [category: string]: {
      词汇: string[];
      使用频率: string;
      典型语境: string[];
      真实例句: string[];
    };
  };
  句式特征: {
    [pattern: string]: {
      模式: string[];
      使用频率: string;
    };
  };
  写作技巧: {
    金句识别: {
      数量: number;
      类型: string[];
      位置偏好: string[];
      典型金句: string[];
    };
  };
  情绪节奏: {
    引入段: number;
    论证段: number;
    高潮段: number;
    结尾段: number;
    整体模式: string;
  };
  量化指标: {
    总字数: number;
    平均句长: number;
    口语化程度: number; // 0-10
    讽刺力度: number; // 0-10
    金句密度: string;
  };
}

export interface AuthorFingerprint {
  基本信息: {
    分析文章数: number;
    生成时间: string;
  };
  风格DNA: {
    口语化基因: any;
    句式基因: any;
  };
  量化指标: any;
  写作建议: string[];
}
```

## 实施步骤

### 第1周：基础架构搭建
1. 扩展数据库表结构
2. 创建基础的作者和文章管理API
3. 实现简单的文章上传功能
4. 集成DeepSeek API

### 第2周：核心分析功能
1. 完善DeepSeek风格分析提示词
2. 实现异步分析机制
3. 开发本地模式匹配算法
4. 实现作者指纹生成

### 第3周：前端界面
1. 创建作者管理页面
2. 实现文章批量上传
3. 开发风格分析结果展示
4. 实现风格仪表盘

### 第4周：优化完善
1. 实现作者风格对比功能
2. 添加写作建议生成
3. 优化用户体验
4. 性能优化和错误处理

## 技术优势

1. **基于现有基础**：充分利用现有技术栈和数据库
2. **成本可控**：DeepSeek API成本相对较低，只在分析时使用
3. **扩展性好**：分层JSON设计便于后续功能扩展
4. **用户友好**：异步分析不阻塞用户操作

## 关键技术细节

### DeepSeek API集成
- API Key：需要申请DeepSeek开发者账号
- 模型选择：deepseek-chat（性价比最高）
- 成本控制：每1000token约0.001元，分析一篇文章约0.01-0.05元

### 异步处理机制
- 使用消息队列处理分析任务
- 实时推送分析进度给前端
- 失败重试机制

### 错误处理
- DeepSeek API调用失败时的降级方案
- JSON解析失败时的数据清洗
- 网络异常时的重试机制

## 预期效果

- 能够准确识别作者的个人写作风格特征
- 生成量化的风格指标（0-10分制）
- 提供可操作的写作建议
- 支持多作者风格对比
- 界面友好，操作简单

这个方案在现有基础上增量开发，技术风险低，实现效果明确。